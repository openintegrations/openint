name: Release Workflow

on:
  push:
    branches:
      - main

permissions:
  contents: write # Ensure GITHUB_TOKEN has write permissions for creating releases

jobs:
  summarize-prs:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Authenticate GitHub CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh auth status

      - name: Get the latest tag or set initial version
        id: get_latest_tag
        run: |
          if git describe --tags --abbrev=0 > /dev/null 2>&1; then
            LATEST_TAG=$(git describe --tags --abbrev=0)
          else
            LATEST_TAG="v0.0.0"
          fi
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_ENV

      - name: Calculate new version
        run: |
          git fetch --tags

          VERSION=${{ env.latest_tag }}
          VERSION=${VERSION#v}
          MAJOR=$(echo "$VERSION" | cut -d. -f1)
          MINOR=$(echo "$VERSION" | cut -d. -f2)
          PATCH=$(echo "$VERSION" | cut -d. -f3)

          if [ "$VERSION" = "0.0.0" ]; then
            NEW_VERSION="v0.1.0"
          else
            PATCH=$((PATCH + 1))
            NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          fi

          # Debugging: Initial new version
          echo "Initial new version: $NEW_VERSION"

          git fetch --tags --force

          # Check if the tag exists and increment if necessary
          while true; do
            echo "Checking if tag $NEW_VERSION exists..."
            if git tag --list | grep -q "^$NEW_VERSION$"; then
              echo "Tag $NEW_VERSION exists. Incrementing patch version..."
              PATCH=$((PATCH + 1))
              NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
              echo "New incremented version: $NEW_VERSION"
            else
              echo "Tag $NEW_VERSION does not exist. Proceeding with this version."
              break
            fi
          done

          # Debugging: Final new version
          echo "Final new version: $NEW_VERSION"
          echo "new_version=$NEW_VERSION" >> $GITHUB_ENV

      - name: Generate changelog
        id: changelog
        run: |
          if [ "${{ env.latest_tag }}" = "v0.0.0" ]; then
            CHANGES=$(git log --pretty=format:"- %s (%h) by %an")
          else
            CHANGES=$(git log ${{ env.latest_tag }}..HEAD --pretty=format:"- %s (%h) by %an")
          fi
          echo "$CHANGES" > changes.txt
          echo "Changes written to changes.txt"

      - name: Fetch PR data as JSON
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ "${{ env.latest_tag }}" = "v0.0.0" ]; then
            gh pr list --state merged --base main \
              --json number,title,body,author,mergedAt,labels > prs.json
          else
            gh pr list --state merged --base main --search "merged:>$(git show -s --format=%ci ${{ env.latest_tag }})" \
              --json number,title,body,author,mergedAt,labels > prs.json
          fi
          echo "PR data saved to prs.json"

      - name: Format PR data
        run: |
          jq -r '.[] | "- PR #\(.number): \(.title) by \(.author.login)\n> [!IMPORTANT]\n> \(.body // "No description provided.")\n"' prs.json > formatted_prs.txt
          echo "Formatted PR data saved to formatted_prs.txt"

      - name: Combine changelog and PR data
        run: |
          echo "Changes from git log:\n" > changelog.txt
          cat changes.txt >> changelog.txt
          echo "\nChanges from PRs:\n" >> changelog.txt
          cat formatted_prs.txt >> changelog.txt
          echo "Combined changelog written to changelog.txt"

      - name: Extract PR titles and important lines
        run: |
          awk -v repo_url="https://github.com/openintegrations/openint" '
          BEGIN {
              # Use an associative array to store seen PRs
              seen_prs = "";
          }
          /^- PR #[0-9]+:/ {
              match($0, /^- PR #([0-9]+):/, pr);
              pr_title = $0;
              pr_number = pr[1];
              pr_key = pr_number; # Unique key for each PR
          }
          /> \[!IMPORTANT\]/ {
              getline;
              important_line = $0;
              if (!(pr_key in seen_prs)) {
                  seen_prs[pr_key] = 1;
                  print pr_title " (" repo_url "/pull/" pr_number ") -- " important_line;
              }
          }' changelog.txt > formatted_release_notes.txt
          echo "Formatted Release Notes:"
          cat formatted_release_notes.txt

      - name: Summarize PR changes with OpenAI
        id: summarize
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          FORMATTED_OUTPUT=$(cat formatted_release_notes.txt | jq -Rsa .)

          RESPONSE=$(curl -s -X POST https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "$(jq -n --arg changelog "$FORMATTED_OUTPUT" '{
              model: "gpt-4",
              messages: [
                {role: "system", content: "You are an assistant that generates concise and clear release summaries for software projects."},
                {role: "user", content: ("Summarize the following PR changes into a single two-liner summary highlighting important changes:\n\n" + $changelog)}
              ],
              temperature: 0.7
            }')")

          echo "OpenAI API Response:"
          echo "$RESPONSE"

          SUMMARY=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // "No summary generated"')
          echo "summary=$SUMMARY" >> $GITHUB_ENV
          echo "$SUMMARY" > summary_output.txt

      - name: Create Release Notes
        run: |
          SUMMARY=$(cat summary_output.txt)
          echo -e "### Summary\n\n$SUMMARY\n\n### PR Breakdown:\n" > release_notes.txt
          cat formatted_release_notes.txt >> release_notes.txt
          echo "Release notes written to release_notes.txt"

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${{ env.new_version }}" --title "Release ${{ env.new_version }}" --notes-file release_notes.txt
