/**
 * Usage: Copy text body from request to /sql endpoint of neon proxy and use it to run query directly in db
 * Example command given the following input
 * `pbpaste | bun packages/db/scripts/formatNeonProxyPayload.ts`
{
  "queries": [
    {
      "query": "SELECT set_config($1, $2, true)",
      "params": [
        "role",
        "org"
      ]
    },
    {
      "query": "SELECT set_config($1, $2, true)",
      "params": [
        "request.jwt.claim.org_id",
        "org_2tpltLjGSrsaDEqBOU5TgNTsLYC"
      ]
    },
    {
      "query": "insert into \"connection\" (\"display_name\", \"customer_id\", \"disabled\", \"metadata\", \"id\") values ($1, $2, $3, $4, $5) on conflict (\"id\") do update set \"display_name\" = excluded.\"display_name\", \"customer_id\" = excluded.\"customer_id\", \"disabled\" = excluded.\"disabled\", \"metadata\" = COALESCE(\"connection\".\"metadata\", '{}'::jsonb) ||excluded.\"metadata\" where (\"connection\".\"display_name\" IS DISTINCT FROM excluded.\"display_name\" or \"connection\".\"customer_id\" IS DISTINCT FROM excluded.\"customer_id\" or \"connection\".\"disabled\" IS DISTINCT FROM excluded.\"disabled\" or \"connection\".\"metadata\" IS DISTINCT FROM excluded.\"metadata\")",
      "params": [
        "displayName",
        "fooCustomerId",
        "false",
        "{\"key\":\"value\"}",
        "conn_greenhouse_01JNFHEJMQY4TSMDCFQ80HFBXJ"
      ]
    }
  ]
}
 */

// Generated by AI code below

/**
 * Interface for a query item in the input JSON
 */
interface QueryItem {
  query: string
  params: Array<string | number | boolean | null | object>
}

/**
 * Interface for the input JSON structure
 */
interface SqlQueriesJson {
  queries: QueryItem[]
}

/**
 * Renders SQL queries by replacing parameter placeholders with their actual values
 * @param jsonData - The JSON object containing queries and parameters
 * @returns Array of rendered SQL queries
 */
function renderSqlQueries(jsonData: SqlQueriesJson): string[] {
  const renderedQueries: string[] = []

  // Check if the input has the expected structure
  if (!jsonData || !jsonData.queries || !Array.isArray(jsonData.queries)) {
    throw new Error("Invalid input format. Expected JSON with 'queries' array.")
  }

  // Process each query in the array
  for (const item of jsonData.queries) {
    const {query, params} = item

    if (!query || !params || !Array.isArray(params)) {
      throw new Error(
        "Invalid query item. Each item must have 'query' and 'params' array.",
      )
    }

    // Replace each parameter placeholder with its corresponding value
    let renderedQuery: string = query
    for (let i = 0; i < params.length; i++) {
      const placeholder: string = `$${i + 1}`
      const paramValue = params[i]

      // Format the parameter value based on its type
      let formattedValue: string
      if (typeof paramValue === 'string') {
        // Check if it's already a JSON string
        if (paramValue.startsWith('{') && paramValue.endsWith('}')) {
          formattedValue = `'${paramValue}'`
        } else {
          formattedValue = `'${paramValue}'`
        }
      } else if (paramValue === null) {
        formattedValue = 'NULL'
      } else if (typeof paramValue === 'boolean') {
        formattedValue = paramValue.toString()
      } else if (typeof paramValue === 'object') {
        formattedValue = `'${JSON.stringify(paramValue)}'`
      } else {
        formattedValue = paramValue?.toString() ?? ''
      }

      // Replace the placeholder with the formatted value
      renderedQuery = renderedQuery.replace(placeholder, formattedValue)
    }

    renderedQueries.push(renderedQuery)
  }

  return renderedQueries
}

/**
 * Main function that reads from stdin and processes the input
 */
function main(): void {
  let inputData = ''

  // Read data from standard input
  process.stdin.setEncoding('utf8')

  process.stdin.on('data', (chunk: string) => {
    inputData += chunk
  })

  process.stdin.on('end', () => {
    try {
      console.log('BEGIN;')
      // Parse the JSON input
      const jsonData: SqlQueriesJson = JSON.parse(inputData)

      // Render the SQL queries
      const renderedQueries = renderSqlQueries(jsonData)

      // Output the rendered queries
      renderedQueries.forEach((query, index) => {
        console.log(`-- Query ${index + 1}:`)
        console.log(query + ';')
        console.log('')
      })
      console.log('COMMIT;')
    } catch (error) {
      console.error(
        'Error processing input:',
        error instanceof Error ? error.message : error,
      )
      process.exit(1)
    }
  })

  process.stdin.on('error', (error) => {
    console.error('Error reading from stdin:', error.message)
    process.exit(1)
  })
}

// Run the main function
main()
