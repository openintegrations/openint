/**
 * We have to generate the connector list into actual files because webpack / next.js is extremely not performant
 * when importing modules with dynamic paths at runtime
 */

import * as fs from 'node:fs'
import {join as pathJoin} from 'node:path'
import prettier from 'prettier'
import type {ConnectorDef} from '@openint/cdk'
import {camelCase} from '@openint/util/string-utils'
import prettierConfig from '../../prettier.config'

async function writePretty(filename: string, content: string, pretty = true) {
  fs.mkdirSync(pathJoin(__dirname, 'connectors'), {recursive: true})
  fs.writeFileSync(
    pathJoin(__dirname, 'connectors', filename),
    !pretty
      ? content
      : await prettier.format(
          `
    // generated by _generateConnectorLists.ts. Do not modify by hand
    ${content}`,
          {...prettierConfig, parser: 'typescript'},
        ),
  )
}

const connectorList = fs
  .readdirSync(pathJoin(__dirname, '../../connectors'), {
    withFileTypes: true,
  })
  .filter((r) => r.isDirectory())
  .map((d) => {
    const path = pathJoin(__dirname, '../../connectors', d.name)
    const def = fs.existsSync(pathJoin(path, 'def.ts'))
      ? // TODO: Automate generation of package.json is still needed, otherwise does not work for new packages
        // @see https://share.cleanshot.com/wDmqwsHS
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        (require(`@openint/${d.name}/def`).default as ConnectorDef)
      : undefined
    // we do some validation also

    if (def && `connector-${def.name}` !== d.name) {
      throw new Error(`Mismatched connector: ${def.name} dir: ${d.name}`)
    }
    return {
      name: def?.name,
      dirName: d.name,
      varName: camelCase(d.name),
      imports: {
        def: fs.existsSync(pathJoin(path, 'def.ts'))
          ? `@openint/${d.name}/def`
          : undefined,
        client: fs.existsSync(pathJoin(path, 'client.ts'))
          ? `@openint/${d.name}/client`
          : undefined,
        server: fs.existsSync(pathJoin(path, 'server.ts'))
          ? `@openint/${d.name}/server`
          : undefined,
      },
    }
  })
async function main() {
  await writePretty(
    'meta.js',
    `
  module.exports = ${JSON.stringify(connectorList)}
  `,
  )

  const entries = ['def', 'client', 'server'] as const

  for (const entry of entries) {
    const list = connectorList.filter((int) => !!int.imports[entry])
    await writePretty(
      `connectors.${entry}.ts`,
      `${list
        .map(
          (int) =>
            `import {default as ${int.varName}} from '${int.imports[entry]}'`,
        )
        .join('\n')}
    export const ${entry}Connectors = {${list
      .map(({name, varName}) => `${name}: ${varName},`)
      .join('\n')}}
  `,
    )
  }
  const mergedlist = connectorList.filter((int) =>
    Object.values(int.imports).some((v) => !!v),
  )

  await writePretty(
    'connectors.merged.ts',
    `${mergedlist
      .flatMap((int) => {
        const validImports = Object.fromEntries(
          Object.entries(int.imports)
            .filter(([, v]) => !!v)
            // Temp hack because mergedConnectors are only ever used server side
            // This avoids server needing to import client side code unnecessarily
            .filter(([k]) => k !== 'client'),
        )
        return [
          Object.entries(validImports)
            .map(
              ([k, v]) => `import {default as ${int.varName}_${k}} from '${v}'`,
            )
            .join('\n'),
          `const ${int.varName} = {
            ${Object.keys(validImports)
              .map((k) => `...${int.varName}_${k}`)
              .join(',')}
        }`,
        ]
      })
      .join('\n')}


  export const mergedConnectors = {${mergedlist
    .map(({name, varName}) => `${name}: ${varName},`)
    .join('\n')}}
`,
  )
}

// eslint-disable-next-line unicorn/prefer-top-level-await
void main()
